# **SoLong**

그리고 물고기는 고마웠어요.

_요약: 이 프로젝트는 아주 간단한 2D 게임을 만들어 볼 겁니다. 텍스쳐, 스프라이트, 기본적인 게임플레이 요소들을 다뤄볼 있도록 설계되어 있어요._

# **Contents**

| Chapter | Contents                                   | page |
| :-----: | :----------------------------------------- | :--: |
|    1    | [**Foreword**](#Chapter-1)                 |  2   |
|    2    | [**Goals**](#Chapter-2)                    |  3   |
|    3    | [**Common Instructions**](#Chapter-3)      |  4   |
|    4    | [**Mandatory part - So Long**](#Chapter-4) |  5   |
|    5    | [**Bonus part**](#Chapter-5)               |  8   |
|    6    | [**Examples**](#Chapter-6)                 |  9   |

<br>

# **Chapter 1**

## Foreword

개발자가 된다는 건 스스로 게임을 만들기에 정말 좋은 요건이기도 하죠.

하지만 좋은 게임을 만들기 위해선 좋은 자료들 또한 필요하지요.

2D 게임을 만들기 위해선, 맵 타일이나 타일셋, 스프라이트, 스프라이트 시트 등이 필요합니다.

감사하게도! [이곳처럼](https://itch.io/game-assets/free/tag-sprites) 몇몇 예술가분들께서 작업물을 공유해주신 공간이 있습니다.

여러분이 무엇을 하던지간에, 다른 사람들의 창작물을 존중해주세요.

<br>

# **Chapter 2**

## Goals

이번 프로젝트의 목표는 이전에 진행했던 이러한 프로젝트와 비슷합니다 : 엄격함 (Rigor), C언어 사용하기, 기본적인 알고리즘 사용하기, 정보 검색 등

그래픽 디자인 프로젝트로서, `so long`은 창, 색상, 이벤트, 모양 채우기 등과 같은 분야에서 여러분의 능력 향상을 도울 것입니다.

<br>

# **Chapter 3**

## Common Instructions

- 프로젝트는 Norm 규칙에 맞춰 작성되어야 합니다. 보너스 파일/함수가 존재할 경우, 그 또한 norm 검사에 포함되며 norm error가 있을 시 0점을 받게 됩니다.

- 함수들은 정의되지 않은 행동들과 별개로 예기치 않게 중단되어서는 안 됩니다.(예를 들어, segmentation fault, bus error, double free 등) 만약 이렇게 중단되면, 당신의 프로젝트는 작동하지 않는 것으로 여겨지고 평가에서 0점을 받을 것입니다.

- 필요한 경우 heap에 할당된 모든 메모리 공간은 적절하게 해제되어야 합니다. 메모리 누수는 용납되지 않습니다.

- 과제에서 필요한 경우, **-Wall -Wextra -Werror** 플래그를 지정하여 컴파일을 수행하는 **Makefile**을 제출해야 합니다. Makefile은 relink 되어서는 안 됩니다.

- **Makefile**은 최소한 **$(NAME), all, clean, fclean, re** 규칙을 포함해야 합니다.

- 프로젝트에 보너스를 제출하려면, Makefile에 **보너스 규칙**을 포함해야 합니다. 이 보너스 규칙은 프로젝트의 메인 파트에서 금지되었던 모든 다양한 헤더, 라이브러리, 또는 함수들을 추가하여야 합니다. 보너스 과제는 반드시 \_**bonus**.{c/h}라는 별도의 파일에 있어야 합니다. 반드시 수행하여야 하는 메인 파트의 평가와 보너스 파트의 평가는 별도로 이뤄집니다.

- 만일 프로젝트에서 여러분의 libft 사용을 허용한다면, 소스들과 관련 Makefile을 함께 루트 폴더 안에 있는 libft 폴더에 복사해야 합니다. 프로젝트의 Makefile은 우선 libft의 Makefile을 사용하여 라이브러리를 컴파일한 다음, 프로젝트를 컴파일해야 합니다.

- **이 과제물을 제출할 필요가 없고, 채점 받을 필요가 없을지라도,** 저희는 여러분들이 프로젝트를 위한 테스트 프로그램을 만들 것을 권장합니다. 이것은 여러분의 과제물과 동료들의 과제물을 쉽게 테스트할 수 있게 도울 것입니다. 또한, 평가를 진행할 때 이러한 테스트 프로그램들이 특히 유용하다는 사실을 알게 될 것입니다. 평가 시에는 여러분의 테스트 프로그램과 평가 받는 동료의 테스트 프로그램들을 당연히 자유롭게 사용할 수 있습니다.

- 할당된 git 저장소에 과제물을 제출하세요. 오직 git 저장소에 있는 과제물만 등급이 매겨질 것입니다. Deepthought가 평가하는 과제의 경우엔, 동료평가 이후에 Deepthought가 수행됩니다. 만약 Deepthought 평가 중에 오류가 발생한다면, 그 즉시 평가는 중지될 것입니다.

<br>

# **Chapter 4**

## Mandatory part - so long

<br>

| **프로그램 이름**            | so_long                                                                                                                                                                                                     |
| ---------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **제출할 파일**              | 제작에 필요한 모든 파일들                                                                                                                                                                                   |
| **Makefile 규칙**            | all, clean, fclean, re, bonus                                                                                                                                                                               |
| **인자**                     | \*.ber 형식의 맵                                                                                                                                                                                            |
| **사용가능한 <br>외부 함수** | open, close, read, write, malloc, free, perror, strerror, exit <br> MinilibX 라이브러리 내의 모든 함수들                                                                                                    |
| **직접 만든 libft**          | 사용 가능                                                                                                                                                                                                   |
| **설명**                     | 여러분은 `돌고래`가 물고기 몇 마리를 잡아먹은 뒤 `지구`를 탈출하는 작은 2D 게임을 만들어야 합니다. 굳이 돌고래나 물고기가 될 필요는 없습니다. 주인공이 특정 수집품을 모은 뒤 공간을 떠나는 방식이면 됩니다. |

<br>

제약은 다음과 같습니다:

- 반드시 miniLibX를 사용해야 합니다. (운영체제에서 이용 가능한 라이브러리와 과제에서 제공되는 소스 중 하나를 사용하셔야 합니다) 만약 제공받은 소스를 이용해 작업하기로 했다면, Libft의 **공통 지침** (Common Instructions) 과 같은 규칙을 따라야 합니다.

- 작업 창 관리는 부드럽게 동작하여야 합니다. (창 최소화, 다른 창으로 전환 등의 동작)

- 예시로는 물고기를 잡아먹는 돌고래를 들었지만, 주제는 어떤 것으로 정하셔도 상관 없습니다.

- 지도는 세 가지 요소들로 구성되어 있습니다: 벽, 수집품, 그리고 빈 공간

- 플레이어의 목표는 모든 수집품을 모으고 최소한의 움직임으로 맵을 탈출하는 것입니다.

- 각 움직임마다 현재까지 움직인 횟수가 쉘에 출력되어야 합니다.

- 플레이어는 다음 방향으로 움직여야 합니다: 상하좌우

- 게임은 2D 시점으로 제작하여야 합니다. (탑뷰 또는 프로필)

- 실시간으로 진행되는 게임일 필요는 없습니다.

- 플레이어는 벽을 뚫고 지나갈 수 없습니다.

- 프로그램은 다음과 같은 룰을 따르며 이미지를 화면에 표시하여야 합니다:

  - W, A, S, D 키를 이용하여 주인공을 조작합니다.

  - `ESC`는 창을 닫고 게임을 정상적으로 종료합니다.

  - 창 좌상단의 빨간 버튼 (mac) 또는 우상단의 빨간 X (windows) 를 누르면 창을 닫고 게임을 정상적으로 종료합니다.

  - `minilibX`의 `images`를 사용하는 것을 강력히 추천합니다!

- 여러분의 프로그램은 `.ber` 확장자의 파일을 첫 번째 인자로 받아야 합니다.

  - 지도는 단 5개의 가능한 문자열로만 구성되어야 합니다: **0**은 빈 공간, **1**은 벽, **C**는 수집품, **E**는 맵의 출구, **P**는 주인공의 시작지점입니다.

  - 다음은 간단한 지도의 예시입니다:

  ```
  1111111111111
  10010000000C1
  1000011111001
  1P0011E000001
  1111111111111
  ```

  - 지도는 벽으로 둘러쌓여 있어야 합니다. 그렇지 않으면 에러를 반환해야 합니다.

  - 지도는 최소한 하나의 출구, 하나의 물고기 (수집품), 하나의 시작 지점을 포함해야 합니다.

  - 지도에서 출구로 가는 길의 유무 판단 (검증)은 굳이 해주지 않으셔도 됩니다.

  - 지도는 반드시 직사각형 모양이어야 합니다.

  - 이하의 규칙을 준수한 모든 종류의 지도를 파싱할 수 있어야 합니다.

  - 또 하나의 간단한 `.ber` 지도의 예시입니다:

  ```
  1111111111111111111111111111111111
  1E0000000000000C00000C000000000001
  1010010100100000101001000000010101
  1010010010101010001001000000010101
  1P0000000C00C0000000000000000000C1
  1111111111111111111111111111111111
  ```

  - 지도 파일에서 어떠한 허점이 발견된다면, 프로그램은 "Error\n" 과 여러분이 직접 정한 에러 메시지를 출력한 후 제대로 종료되어야 합니다.

<br>

# **Chapter 5**

## Bonus part

<br>

```
⚠️
보너스는 필수로 구현해야 하는 파트가 완벽할 때만 평가될 것입니다. 저희가 말하는 '완벽함' 이란, 어떠한 경우에도 - 잘못된 사용과 같은 끔찍한 실수 등 - 실패하지 않고 동작해야 한다는 의미입니다. 쉽게 말하자면, 필수로 구현해야 하는 파트에서 만점을 받지 못한다면, 보너스는 완전히 '무시될' 것입니다.
```

보너스 리스트:

- 적 추가. 주인공이 적에게 닿으면 게임에서 패배합니다.

- 스프라이트에 움직임을 주는 건 어떨까요?

- 쉘 대신, 화면상에 현재까지 움직인 횟수를 출력할 수도 있습니다.

```
💡
여러분은 뒤에서 더 재밌는 게임들을 만들어 볼 수 있어요.
너무 많은 시간을 할애하지 마세요!!!
```

![안녕히!](solong.png)

<br>

# **Chapter 6**

## Examples

<br>

![예시](examples.png)

사진 6.1: 그래픽 디자인 센스가 (보너스급으로) 많이 구린 `so_long` 예시들!
